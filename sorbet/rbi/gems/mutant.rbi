# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mutant/all/mutant.rbi
#
# mutant-027b3d8f7508
module Mutant
end
module Mutant::Functor
  def fmap(*arg0); end
  def require_block; end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class Mutant::Maybe
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Memoizable
end
class Mutant::Maybe::Nothing < Mutant::Maybe
  def apply(&block); end
  def fmap(&block); end
  def new; end
end
class Mutant::Maybe::Just < Mutant::Maybe
  def apply; end
  def fmap; end
  include Anonymous_Concord_20
  include Anonymous_Module_19
end
module Anonymous_Module_19
  def initialize(*args); end
  def value; end
  include Anonymous_Equalizer_21
  include Equalizer::Methods
end
module Anonymous_Equalizer_21
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_20
end
class Mutant::Either
  def self.new(*args, &block); end
  def self.wrap_error(error); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Anonymous_Module_22
  include Memoizable
end
module Anonymous_Module_22
  def initialize(*args); end
  def value; end
  include Anonymous_Equalizer_23
  include Equalizer::Methods
end
module Anonymous_Equalizer_23
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Either::Left < Mutant::Either
  def apply(&block); end
  def either(left, _right); end
  def fmap(&block); end
  def from_left; end
  def from_right; end
  def lmap; end
end
class Mutant::Either::Right < Mutant::Either
  def apply; end
  def either(_left, right); end
  def fmap; end
  def from_left; end
  def from_right; end
  def lmap(&block); end
end
module Mutant::Bootstrap
  def config; end
  def parser; end
  def self.anima; end
  def self.apply(world, config); end
  def self.expression(reporter, expression_parser, scope); end
  def self.infect(env); end
  def self.matchable_scopes(world, config); end
  def self.scope_name(reporter, scope); end
  def self.semantics_warning(reporter, format, options); end
  def world; end
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_24
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_24
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Env
  def amount_mutations(&block); end
  def amount_selected_tests(&block); end
  def amount_subjects(&block); end
  def amount_total_tests(&block); end
  def config; end
  def integration; end
  def kill(mutation); end
  def matchable_scopes; end
  def mutations; end
  def parser; end
  def run_mutation_tests(mutation, tests); end
  def selected_tests(&block); end
  def selections(&block); end
  def selector; end
  def self.anima; end
  def self.empty(world, config); end
  def subjects; end
  def test_subject_ratio(&block); end
  def warn(message); end
  def world; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_25
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_25
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Mutant::Util
  def self.one(array); end
end
class Mutant::Util::SizeError < IndexError
end
class Mutant::Registry
  def initialize; end
  def lookup(type); end
  def register(type, klass); end
  include Anonymous_Concord_27
  include Anonymous_Module_26
end
module Anonymous_Module_26
  def contents; end
  def initialize(*args); end
  include Anonymous_Equalizer_28
  include Equalizer::Methods
end
module Anonymous_Equalizer_28
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_27
end
class Mutant::Registry::RegistryError < TypeError
end
module Mutant::AST
  def self.find_last_path(node, &predicate); end
  def self.walk(node, stack, &block); end
end
module Mutant::AST::Sexp
  def n_not(node); end
  def s(type, *children); end
end
module Mutant::AST::Types
end
module Mutant::AST::Nodes
  extend Mutant::AST::Sexp
end
module Mutant::AST::NamedChildren
  def self.included(host); end
end
module Mutant::AST::NamedChildren::InstanceMethods
  def children; end
end
module Mutant::AST::NamedChildren::ClassMethods
  def children(*names); end
  def define_named_child(name, index); end
  def define_private_method(name, &block); end
  def define_remaining_children(names); end
end
module Mutant::AST::NodePredicates
  def n___ENCODING__?(node); end
  def n___FILE__?(node); end
  def n___LINE__?(node); end
  def n_alias?(node); end
  def n_and?(node); end
  def n_and_asgn?(node); end
  def n_arg?(node); end
  def n_arg_expr?(node); end
  def n_args?(node); end
  def n_array?(node); end
  def n_back_ref?(node); end
  def n_begin?(node); end
  def n_block?(node); end
  def n_block_pass?(node); end
  def n_blockarg?(node); end
  def n_blockarg_expr?(node); end
  def n_break?(node); end
  def n_case?(node); end
  def n_casgn?(node); end
  def n_cbase?(node); end
  def n_class?(node); end
  def n_complex?(node); end
  def n_const?(node); end
  def n_csend?(node); end
  def n_cvar?(node); end
  def n_cvasgn?(node); end
  def n_def?(node); end
  def n_defined?(node); end
  def n_defs?(node); end
  def n_dstr?(node); end
  def n_dsym?(node); end
  def n_eflipflop?(node); end
  def n_empty?(node); end
  def n_ensure?(node); end
  def n_erange?(node); end
  def n_false?(node); end
  def n_float?(node); end
  def n_for?(node); end
  def n_gvar?(node); end
  def n_gvasgn?(node); end
  def n_hash?(node); end
  def n_ident?(node); end
  def n_if?(node); end
  def n_iflipflop?(node); end
  def n_index?(node); end
  def n_indexasgn?(node); end
  def n_int?(node); end
  def n_irange?(node); end
  def n_ivar?(node); end
  def n_ivasgn?(node); end
  def n_kwarg?(node); end
  def n_kwbegin?(node); end
  def n_kwoptarg?(node); end
  def n_kwrestarg?(node); end
  def n_kwsplat?(node); end
  def n_lambda?(node); end
  def n_lvar?(node); end
  def n_lvasgn?(node); end
  def n_masgn?(node); end
  def n_match_current_line?(node); end
  def n_match_with_lvasgn?(node); end
  def n_meth_ref?(node); end
  def n_mlhs?(node); end
  def n_module?(node); end
  def n_next?(node); end
  def n_nil?(node); end
  def n_nth_ref?(node); end
  def n_objc_kwarg?(node); end
  def n_objc_restarg?(node); end
  def n_objc_varargs?(node); end
  def n_op_asgn?(node); end
  def n_optarg?(node); end
  def n_or?(node); end
  def n_or_asgn?(node); end
  def n_pair?(node); end
  def n_postexe?(node); end
  def n_preexe?(node); end
  def n_procarg0?(node); end
  def n_rational?(node); end
  def n_redo?(node); end
  def n_regexp?(node); end
  def n_regopt?(node); end
  def n_resbody?(node); end
  def n_rescue?(node); end
  def n_restarg?(node); end
  def n_restarg_expr?(node); end
  def n_retry?(node); end
  def n_return?(node); end
  def n_root?(node); end
  def n_sclass?(node); end
  def n_self?(node); end
  def n_send?(node); end
  def n_shadowarg?(node); end
  def n_splat?(node); end
  def n_str?(node); end
  def n_super?(node); end
  def n_sym?(node); end
  def n_true?(node); end
  def n_undef?(node); end
  def n_until?(node); end
  def n_until_post?(node); end
  def n_when?(node); end
  def n_while?(node); end
  def n_while_post?(node); end
  def n_xstr?(node); end
  def n_yield?(node); end
  def n_zsuper?(node); end
end
module Mutant::AST::Meta
end
class Mutant::AST::Meta::Send
  def arguments; end
  def attribute_assignment?; end
  def binary_method_operator?; end
  def naked_proc?; end
  def proc?; end
  def proc_new?; end
  def receiver; end
  def receiver_possible_top_level_const?; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def selector; end
  extend Mutant::AST::NamedChildren::ClassMethods
  include Anonymous_Module_29
  include Mutant::AST::NamedChildren
  include Mutant::AST::NamedChildren::InstanceMethods
end
module Anonymous_Module_29
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_30
  include Equalizer::Methods
end
module Anonymous_Equalizer_30
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::AST::Meta::Const
  def base; end
  def name; end
  def possible_top_level?; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  extend Mutant::AST::NamedChildren::ClassMethods
  include Anonymous_Module_31
  include Mutant::AST::NamedChildren
  include Mutant::AST::NamedChildren::InstanceMethods
end
module Anonymous_Module_31
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_32
  include Equalizer::Methods
end
module Anonymous_Equalizer_32
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::AST::Meta::Symbol
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  extend Mutant::AST::NamedChildren::ClassMethods
  include Anonymous_Module_33
  include Mutant::AST::NamedChildren
  include Mutant::AST::NamedChildren::InstanceMethods
end
module Anonymous_Module_33
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_34
  include Equalizer::Methods
end
module Anonymous_Equalizer_34
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::AST::Meta::Optarg
  def default_value; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def used?; end
  extend Mutant::AST::NamedChildren::ClassMethods
  include Anonymous_Module_35
  include Mutant::AST::NamedChildren
  include Mutant::AST::NamedChildren::InstanceMethods
end
module Anonymous_Module_35
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_36
  include Equalizer::Methods
end
module Anonymous_Equalizer_36
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::AST::Meta::Resbody
  def assignment; end
  def body; end
  def captures; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  extend Mutant::AST::NamedChildren::ClassMethods
  include Anonymous_Module_37
  include Mutant::AST::NamedChildren
  include Mutant::AST::NamedChildren::InstanceMethods
end
module Anonymous_Module_37
  def initialize(*args); end
  def node; end
  include Anonymous_Equalizer_38
  include Equalizer::Methods
end
module Anonymous_Equalizer_38
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Parser
  def call(path); end
  def initialize; end
  include Adamantium::Mutable
  include Equalizer::Methods
end
class Mutant::Isolation
  def call(*arg0); end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class Mutant::Isolation::Result
  def add_error(error); end
  def error(*arg0); end
  def log; end
  def next(*arg0); end
  def self.new(*args, &block); end
  def success?; end
  def value(*arg0); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Memoizable
end
class Mutant::Isolation::Result::Success < Mutant::Isolation::Result
  def log; end
  def self.new(_value, _log = nil); end
  def value; end
  include Anonymous_Concord_Public_40
  include Anonymous_Module_39
end
module Anonymous_Module_39
  def initialize(*args); end
  def log; end
  def value; end
  include Anonymous_Equalizer_41
  include Equalizer::Methods
end
module Anonymous_Equalizer_41
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_40
end
class Mutant::Isolation::Result::Exception < Mutant::Isolation::Result
  def value; end
  include Anonymous_Concord_Public_43
  include Anonymous_Module_42
end
module Anonymous_Module_42
  def initialize(*args); end
  def value; end
  include Anonymous_Equalizer_44
  include Equalizer::Methods
end
module Anonymous_Equalizer_44
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_43
end
class Mutant::Isolation::Result::ErrorChain < Mutant::Isolation::Result
  def next; end
  def value; end
  include Anonymous_Concord_Public_46
  include Anonymous_Module_45
end
module Anonymous_Module_45
  def initialize(*args); end
  def next; end
  def value; end
  include Anonymous_Equalizer_47
  include Equalizer::Methods
end
module Anonymous_Equalizer_47
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_46
end
class Mutant::Isolation::None < Mutant::Isolation
  def call; end
end
class Mutant::Isolation::Fork < Mutant::Isolation
  def call(&block); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_48
  include Memoizable
end
module Anonymous_Module_48
  def initialize(*args); end
  def world; end
  include Anonymous_Equalizer_49
  include Equalizer::Methods
end
module Anonymous_Equalizer_49
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Isolation::Fork::ChildError < Mutant::Isolation::Result
  def log; end
  def value; end
  include Anonymous_Concord_Public_51
  include Anonymous_Module_50
end
module Anonymous_Module_50
  def initialize(*args); end
  def log; end
  def value; end
  include Anonymous_Equalizer_52
  include Equalizer::Methods
end
module Anonymous_Equalizer_52
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_51
end
class Mutant::Isolation::Fork::ForkError < Mutant::Isolation::Result
  include Anonymous_Equalizer_53
  include Equalizer::Methods
end
module Anonymous_Equalizer_53
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Isolation::Fork::Pipe
  def child; end
  def parent; end
  def reader; end
  def self.anima; end
  def self.with(io); end
  def writer; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_54
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_54
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Isolation::Fork::Parent
  def add_result(result); end
  def block; end
  def call; end
  def log_pipe; end
  def read_child_result(pid); end
  def read_fragments(targets); end
  def result_pipe; end
  def self.anima; end
  def self.call(*args); end
  def start_child; end
  def wait_child(pid, log_fragments); end
  def world; end
  extend Procto::ClassMethods
  include Anima::InstanceMethods
  include Anonymous_Anima_56
  include Anonymous_Equalizer_55
  include Equalizer::Methods
end
module Anonymous_Anima_56
end
module Anonymous_Equalizer_55
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Isolation::Fork::Child
  def block; end
  def call; end
  def log_pipe; end
  def result_pipe; end
  def self.anima; end
  def self.call(*args); end
  def world; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Procto::ClassMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_57
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_57
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Mutant::Parallel
  def self.async(config); end
  def self.shared(klass, config, **attributes); end
  def self.threads(config, worker); end
  def self.worker(config, **shared); end
end
class Mutant::Parallel::Sink
  def result(*arg0); end
  def self.new(*args, &block); end
  def status(*arg0); end
  def stop?(*arg0); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class Mutant::Parallel::Config
  def condition_variable; end
  def jobs; end
  def mutex; end
  def processor; end
  def self.anima; end
  def sink; end
  def source; end
  def thread; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_58
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_58
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Parallel::Status
  def active_jobs; end
  def done; end
  def done?; end
  def payload; end
  def self.anima; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_59
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_59
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Parallel::Driver
  def finalize(status); end
  def self.anima; end
  def status; end
  def threads; end
  def var_active_jobs; end
  def var_final; end
  def var_sink; end
  def wait_timeout(timeout); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_60
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_60
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Parallel::Source
  def next(*arg0); end
  def next?(*arg0); end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class Mutant::Parallel::Source::Job
  def index; end
  def payload; end
  def self.anima; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_61
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_61
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Parallel::Source::NoJobError < RuntimeError
end
class Mutant::Parallel::Source::Array
  def initialize(*arg0); end
  def next; end
  def next?; end
  include Anonymous_Concord_63
  include Anonymous_Module_62
end
module Anonymous_Module_62
  def initialize(*args); end
  def jobs; end
  include Anonymous_Equalizer_64
  include Equalizer::Methods
end
module Anonymous_Equalizer_64
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_63
end
class Mutant::Parallel::Worker
  def add_result(result); end
  def call; end
  def finalize; end
  def job_done(job); end
  def job_start(job); end
  def next_job; end
  def processor; end
  def self.anima; end
  def var_active_jobs; end
  def var_final; end
  def var_running; end
  def var_sink; end
  def var_source; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_65
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_65
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Mutant::RequireHighjack
  def self.call(target, callback); end
end
class Mutant::Mutation
  def code(&block); end
  def identification(&block); end
  def insert(kernel); end
  def monkeypatch(&block); end
  def node; end
  def original_source; end
  def self.new(*args, &block); end
  def self.success?(test_result); end
  def sha1(&block); end
  def source(&block); end
  def subject; end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Anonymous_Concord_Public_67
  include Anonymous_Module_66
  include Memoizable
end
module Anonymous_Module_66
  def initialize(*args); end
  def node; end
  def subject; end
  include Anonymous_Equalizer_68
  include Equalizer::Methods
end
module Anonymous_Equalizer_68
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_67
end
class Mutant::Mutation::Evil < Mutant::Mutation
end
class Mutant::Mutation::Neutral < Mutant::Mutation
end
class Mutant::Mutation::Noop < Mutant::Mutation::Neutral
end
class Mutant::Mutator
  def dispatch(*arg0); end
  def dup_input; end
  def emit(object); end
  def initialize(_input, _parent = nil); end
  def new?(object); end
  def output; end
  def run(mutator); end
  def self.call(*args); end
  def self.handle(*types); end
  def self.mutate(node, parent = nil); end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Procto::ClassMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_69
  include Memoizable
end
module Anonymous_Module_69
  def initialize(*args); end
  def input; end
  def parent; end
  include Anonymous_Equalizer_70
  include Equalizer::Methods
end
module Anonymous_Equalizer_70
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Mutator::Util < Mutant::Mutator
end
class Mutant::Mutator::Util::Array < Mutant::Mutator::Util
end
class Mutant::Mutator::Util::Array::Presence < Mutant::Mutator::Util
  def dispatch; end
end
class Mutant::Mutator::Util::Array::Element < Mutant::Mutator::Util
  def dispatch; end
end
class Mutant::Mutator::Util::Symbol < Mutant::Mutator::Util
  def dispatch; end
end
class Mutant::Mutator::Node < Mutant::Mutator
  def children_indices(range); end
  def delete_child(index); end
  def dup_node; end
  def emit_child_update(index, node); end
  def emit_nil; end
  def emit_propagation(node); end
  def emit_self; end
  def emit_singletons; end
  def emit_type(*children); end
  def left_assignment?; end
  def mutate_child(index, &block); end
  def mutate_single_child; end
  def node; end
  def parent_node; end
  def parent_type; end
  def self.define_named_child(name, index); end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  extend Mutant::AST::NamedChildren::ClassMethods
  include AbstractType
  include Mutant::AST::NamedChildren
  include Mutant::AST::NamedChildren::InstanceMethods
end
class Mutant::Mutator::Node::Generic < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::Literal < Mutant::Mutator::Node
  def emit_values; end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class Mutant::Mutator::Node::Literal::Boolean < Mutant::Mutator::Node::Literal
  def dispatch; end
end
class Mutant::Mutator::Node::Literal::Range < Mutant::Mutator::Node::Literal
  def dispatch; end
  def emit_inverse; end
  def emit_lower_bound(node); end
  def emit_lower_bound_mutations(&block); end
  def emit_upper_bound(node); end
  def emit_upper_bound_mutations(&block); end
  def lower_bound; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def upper_bound; end
end
class Mutant::Mutator::Node::Literal::Symbol < Mutant::Mutator::Node::Literal
  def dispatch; end
  def emit_value(node); end
  def emit_value_mutations(&block); end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end
class Mutant::Mutator::Node::Literal::String < Mutant::Mutator::Node::Literal
  def dispatch; end
end
class Mutant::Mutator::Node::Literal::Integer < Mutant::Mutator::Node::Literal
  def dispatch; end
  def value; end
  def values; end
end
class Mutant::Mutator::Node::Literal::Float < Mutant::Mutator::Node::Literal
  def dispatch; end
  def emit_special_cases; end
  def values; end
end
class Mutant::Mutator::Node::Literal::Array < Mutant::Mutator::Node::Literal
  def dispatch; end
  def emit_first(node); end
  def emit_first_mutations(&block); end
  def first; end
  def mutate_body; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Literal::Hash < Mutant::Mutator::Node::Literal
  def dispatch; end
  def mutate_body; end
end
class Mutant::Mutator::Node::Literal::Hash::Pair < Mutant::Mutator::Node
  def dispatch; end
  def emit_key(node); end
  def emit_key_mutations(&block); end
  def emit_value(node); end
  def emit_value_mutations(&block); end
  def key; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end
class Mutant::Mutator::Node::Literal::Regex < Mutant::Mutator::Node::Literal
  def dispatch; end
  def options; end
end
class Mutant::Mutator::Node::Literal::Nil < Mutant::Mutator::Node::Literal
  def dispatch; end
end
class Mutant::Mutator::Node::Argument < Mutant::Mutator::Node
  def dispatch; end
  def emit_name(node); end
  def emit_name_mutation; end
  def emit_name_mutations(&block); end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def skip?; end
end
class Mutant::Mutator::Node::Argument::Optional < Mutant::Mutator::Node::Argument
  def default; end
  def dispatch; end
  def emit_default(node); end
  def emit_default_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_required_mutation; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Arguments < Mutant::Mutator::Node
  def dispatch; end
  def emit_argument_mutations; end
  def emit_argument_presence; end
  def emit_mlhs_expansion; end
  def emit_procarg(arg); end
  def invalid_argument_replacement?(mutant, index); end
  def mlhs_childs_with_index; end
end
class Mutant::Mutator::Node::Begin < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::Binary < Mutant::Mutator::Node
  def dispatch; end
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_left_negation; end
  def emit_operator_mutations; end
  def emit_promotions; end
  def emit_right(node); end
  def emit_right_mutations(&block); end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end
class Mutant::Mutator::Node::Const < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::Dstr < Mutant::Mutator::Node::Generic
  def dispatch; end
end
class Mutant::Mutator::Node::Dsym < Mutant::Mutator::Node::Generic
  def dispatch; end
end
class Mutant::Mutator::Node::Kwbegin < Mutant::Mutator::Node::Generic
  def dispatch; end
end
module Mutant::Mutator::Node::NamedValue
end
class Mutant::Mutator::Node::NamedValue::Access < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::NamedValue::Access::Ivar < Mutant::Mutator::Node::NamedValue::Access
  def attribute_name; end
  def dispatch; end
  def emit_attribute_read; end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::NamedValue::ConstantAssignment < Mutant::Mutator::Node
  def cbase; end
  def dispatch; end
  def emit_cbase(node); end
  def emit_cbase_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_remove_const; end
  def emit_value(node); end
  def emit_value_mutations(&block); end
  def mutate_name; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end
class Mutant::Mutator::Node::NamedValue::VariableAssignment < Mutant::Mutator::Node
  def dispatch; end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_value(node); end
  def emit_value_mutations(&block); end
  def mutate_name; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end
class Mutant::Mutator::Node::Next < Mutant::Mutator::Node::Generic
  def dispatch; end
end
class Mutant::Mutator::Node::Break < Mutant::Mutator::Node::Generic
  def dispatch; end
end
class Mutant::Mutator::Node::Noop < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::OrAsgn < Mutant::Mutator::Node
  def dispatch; end
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end
class Mutant::Mutator::Node::AndAsgn < Mutant::Mutator::Node
  def dispatch; end
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end
class Mutant::Mutator::Node::Defined < Mutant::Mutator::Node
  def dispatch; end
  def emit_expression(node); end
  def emit_expression_mutations(&block); end
  def expression; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::OpAsgn < Mutant::Mutator::Node
  def dispatch; end
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_operation(node); end
  def emit_operation_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end
  def left; end
  def operation; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end
class Mutant::Mutator::Node::ConditionalLoop < Mutant::Mutator::Node
  def body; end
  def condition; end
  def dispatch; end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_condition(node); end
  def emit_condition_mutations(&block); end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Yield < Mutant::Mutator::Node::Generic
  def dispatch; end
end
class Mutant::Mutator::Node::Super < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::ZSuper < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::Send < Mutant::Mutator::Node
  def arguments; end
  def dispatch; end
  def emit_argument_propagation; end
  def emit_const_get_mutation; end
  def emit_dig_mutation; end
  def emit_double_negation_mutation; end
  def emit_implicit_self; end
  def emit_integer_mutation; end
  def emit_lambda_mutation; end
  def emit_naked_receiver; end
  def emit_receiver(node); end
  def emit_receiver_mutations(&block); end
  def emit_receiver_selector_mutations; end
  def emit_selector(node); end
  def emit_selector_mutations(&block); end
  def emit_selector_replacement; end
  def emit_selector_specific_mutations; end
  def meta(&block); end
  def mutate_argument_index(index); end
  def mutate_arguments; end
  def mutate_receiver; end
  def normal_dispatch; end
  def receiver; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def selector; end
  include Mutant::AST::Types
end
class Mutant::Mutator::Node::Send::Binary < Mutant::Mutator::Node::Send
  def dispatch; end
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_not_equality_mutation(new_operator); end
  def emit_not_equality_mutations; end
  def emit_operator(node); end
  def emit_operator_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end
  def left; end
  def operator; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end
class Mutant::Mutator::Node::Send::Conditional < Mutant::Mutator::Node::Send
  def dispatch; end
end
class Mutant::Mutator::Node::Send::AttributeAssignment < Mutant::Mutator::Node::Send
  def dispatch; end
  def emit_attribute_read; end
  def mutate_arguments; end
end
class Mutant::Mutator::Node::When < Mutant::Mutator::Node
  def body; end
  def body_index; end
  def dispatch; end
  def mutate_body; end
  def mutate_conditions; end
end
class Mutant::Mutator::Node::Class < Mutant::Mutator::Node
  def body; end
  def dispatch; end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_klass(node); end
  def emit_klass_mutations(&block); end
  def emit_parent(node); end
  def emit_parent_mutations(&block); end
  def klass; end
  def parent; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Define < Mutant::Mutator::Node
  def dispatch; end
  def emit_body_prepend(node); end
  def emit_optarg_body_assignments; end
end
class Mutant::Mutator::Node::Define::Instance < Mutant::Mutator::Node::Define
  def arguments; end
  def body; end
  def emit_arguments(node); end
  def emit_arguments_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Define::Singleton < Mutant::Mutator::Node::Define
  def arguments; end
  def body; end
  def emit_arguments(node); end
  def emit_arguments_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_subject(node); end
  def emit_subject_mutations(&block); end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def subject; end
end
class Mutant::Mutator::Node::MLHS < Mutant::Mutator::Node
  def dispatch; end
end
class Mutant::Mutator::Node::NthRef < Mutant::Mutator::Node
  def dispatch; end
  def emit_number(node); end
  def emit_number_mutations(&block); end
  def number; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::MultipleAssignment < Mutant::Mutator::Node
  def dispatch; end
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end
class Mutant::Mutator::Node::Return < Mutant::Mutator::Node
  def dispatch; end
  def emit_value(node); end
  def emit_value_mutations(&block); end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end
class Mutant::Mutator::Node::Block < Mutant::Mutator::Node
  def arguments; end
  def body; end
  def body_has_control?; end
  def dispatch; end
  def emit_arguments(node); end
  def emit_arguments_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_send(node); end
  def emit_send_mutations(&block); end
  def mutate_body; end
  def mutate_body_receiver; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def send; end
  def valid_send_mutation?(node); end
end
class Mutant::Mutator::Node::If < Mutant::Mutator::Node
  def condition; end
  def dispatch; end
  def else_branch; end
  def emit_condition(node); end
  def emit_condition_mutations(&block); end
  def emit_else_branch(node); end
  def emit_else_branch_mutations(&block); end
  def emit_if_branch(node); end
  def emit_if_branch_mutations(&block); end
  def if_branch; end
  def mutate_condition; end
  def mutate_else_branch; end
  def mutate_if_branch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Case < Mutant::Mutator::Node
  def condition; end
  def dispatch; end
  def emit_condition(node); end
  def emit_condition_mutations(&block); end
  def emit_else_mutations; end
  def emit_when_mutations; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Splat < Mutant::Mutator::Node
  def dispatch; end
  def emit_expression(node); end
  def emit_expression_mutations(&block); end
  def expression; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Regopt < Mutant::Mutator::Node
  def dispatch; end
  def mutated_flags; end
end
class Mutant::Mutator::Node::Resbody < Mutant::Mutator::Node
  def assignment; end
  def body; end
  def captures; end
  def dispatch; end
  def emit_assignment(node); end
  def emit_assignment_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_captures(node); end
  def emit_captures_mutations(&block); end
  def mutate_captures; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Rescue < Mutant::Mutator::Node
  def body; end
  def dispatch; end
  def else_body; end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_concat(child); end
  def emit_else_body(node); end
  def emit_else_body_mutations(&block); end
  def mutate_body; end
  def mutate_else_body; end
  def mutate_rescue_bodies; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::MatchCurrentLine < Mutant::Mutator::Node
  def dispatch; end
  def emit_regexp(node); end
  def emit_regexp_mutations(&block); end
  def regexp; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Index < Mutant::Mutator::Node
  def dispatch; end
  def emit_drop_mutation; end
  def emit_receiver(node); end
  def emit_receiver_mutations(&block); end
  def emit_send_forms; end
  def indices; end
  def mutate_indices; end
  def receiver; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Mutator::Node::Index::Read < Mutant::Mutator::Node::Index
  def index_range; end
end
class Mutant::Mutator::Node::Index::Assign < Mutant::Mutator::Node::Index
  def dispatch; end
  def emit_index_read; end
  def index_range; end
end
class Mutant::Mutator::Node::ProcargZero < Mutant::Mutator::Node
  def argument; end
  def dispatch; end
  def emit_argument(node); end
  def emit_argument_mutations(&block); end
  def emit_argument_node_mutations; end
  def emit_argument_symbol_mutations; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end
class Mutant::Loader
  def binding; end
  def call; end
  def kernel; end
  def self.anima; end
  def self.call(*arguments); end
  def source; end
  def subject; end
  include Anima::InstanceMethods
  include Anonymous_Anima_72
  include Anonymous_Equalizer_71
  include Equalizer::Methods
end
module Anonymous_Anima_72
end
module Anonymous_Equalizer_71
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Loader::Result
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class Mutant::Loader::Result::Success < Mutant::Loader::Result
  def self.instance; end
end
class Mutant::Loader::Result::VoidValue < Mutant::Loader::Result
  def self.instance; end
end
class Mutant::Context
  def identification; end
  def match_expressions(&block); end
  def name_nesting(&block); end
  def nesting(&block); end
  def root(node); end
  def scope; end
  def self.wrap(scope, node); end
  def source_path; end
  def unqualified_name; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Mutant::AST::Sexp
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_73
  include Memoizable
end
module Anonymous_Module_73
  def initialize(*args); end
  def scope; end
  def source_path; end
  include Anonymous_Equalizer_74
  include Equalizer::Methods
end
module Anonymous_Equalizer_74
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Scope
  def expression; end
  def raw; end
  include Anonymous_Concord_Public_76
  include Anonymous_Module_75
end
module Anonymous_Module_75
  def expression; end
  def initialize(*args); end
  def raw; end
  include Anonymous_Equalizer_77
  include Equalizer::Methods
end
module Anonymous_Equalizer_77
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_76
end
class Mutant::Subject
  def context; end
  def expression(*arg0); end
  def identification(&block); end
  def match_expressions(*arg0); end
  def mutations(&block); end
  def neutral_mutation; end
  def node; end
  def prepare; end
  def self.anima; end
  def self.new(*args, &block); end
  def source(&block); end
  def source_line; end
  def source_lines(&block); end
  def source_path; end
  def warnings; end
  def wrap_node(node); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Anima_79
  include Anonymous_Equalizer_78
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Anima_79
end
module Anonymous_Equalizer_78
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Subject::Method < Mutant::Subject
  def expression(&block); end
  def match_expressions(&block); end
  def name; end
  def scope; end
end
class Mutant::Subject::Method::Instance < Mutant::Subject::Method
  def prepare; end
end
class Mutant::Subject::Method::Instance::Memoized < Mutant::Subject::Method::Instance
  def prepare; end
  def wrap_node(mutant); end
  include Mutant::AST::Sexp
end
class Mutant::Subject::Method::Singleton < Mutant::Subject::Method
  def prepare; end
end
class Mutant::Matcher
  def call(*arg0); end
  def self.allowed_subject?(config, subject); end
  def self.from_config(config); end
  def self.ignore_subject?(config, subject); end
  def self.new(*args, &block); end
  def self.select_subject?(config, subject); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Memoizable
end
class Mutant::Matcher::Config
  def add(attribute, value); end
  def format_attribute(attribute_name); end
  def ignore_expressions; end
  def inspect(&block); end
  def inspect_attributes; end
  def match_expressions; end
  def present_attributes; end
  def self.anima; end
  def subject_filters; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_80
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_80
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Matcher::Chain < Mutant::Matcher
  def call(env); end
  include Anonymous_Concord_82
  include Anonymous_Module_81
end
module Anonymous_Module_81
  def initialize(*args); end
  def matchers; end
  include Anonymous_Equalizer_83
  include Equalizer::Methods
end
module Anonymous_Equalizer_83
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_82
end
class Mutant::Matcher::Method < Mutant::Matcher
  def call(env); end
  def evaluator; end
  def scope; end
  def self.new(*args, &block); end
  def target_method; end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Anonymous_Module_84
  include Memoizable
end
module Anonymous_Module_84
  def evaluator; end
  def initialize(*args); end
  def scope; end
  def target_method; end
  include Anonymous_Equalizer_85
  include Equalizer::Methods
end
module Anonymous_Equalizer_85
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Matcher::Method::Evaluator
  def ast; end
  def call; end
  def context; end
  def matched_node_path(&block); end
  def method_name; end
  def self.call(*args); end
  def self.new(*args, &block); end
  def skip?; end
  def source_line; end
  def source_location; end
  def source_path(&block); end
  def subject(&block); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Procto::ClassMethods
  include AbstractType
  include Anonymous_Module_86
  include Memoizable
end
module Anonymous_Module_86
  def env; end
  def initialize(*args); end
  def scope; end
  def target_method; end
  include Anonymous_Equalizer_87
  include Equalizer::Methods
end
module Anonymous_Equalizer_87
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Matcher::Method::Singleton < Mutant::Matcher::Method
  def self.new(scope, method_name); end
end
class Mutant::Matcher::Method::Singleton::Evaluator < Mutant::Matcher::Method::Evaluator
  def line?(node); end
  def match?(node); end
  def name?(node); end
  def receiver?(node); end
  def receiver_name?(node); end
end
class Mutant::Matcher::Method::Instance < Mutant::Matcher::Method
  def self.new(scope, target_method); end
end
class Mutant::Matcher::Method::Instance::Evaluator < Mutant::Matcher::Method::Evaluator
  def match?(node); end
end
class Mutant::Matcher::Method::Instance::Evaluator::Memoized < Mutant::Matcher::Method::Instance::Evaluator
  def source_location; end
end
class Mutant::Matcher::Methods < Mutant::Matcher
  def call(env); end
  def candidate_names; end
  def candidate_scope(*arg0); end
  def matcher; end
  def methods(&block); end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
  include Anonymous_Module_88
end
module Anonymous_Module_88
  def initialize(*args); end
  def scope; end
  include Anonymous_Equalizer_89
  include Equalizer::Methods
end
module Anonymous_Equalizer_89
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Matcher::Methods::Singleton < Mutant::Matcher::Methods
  def access(method_name); end
  def candidate_scope(&block); end
end
class Mutant::Matcher::Methods::Instance < Mutant::Matcher::Methods
  def access(method_name); end
  def candidate_scope; end
end
class Mutant::Matcher::Namespace < Mutant::Matcher
  def call(env); end
  def expression; end
  def match?(scope); end
  def matched_scopes(env); end
  include Anonymous_Concord_Public_91
  include Anonymous_Module_90
end
module Anonymous_Module_90
  def expression; end
  def initialize(*args); end
  include Anonymous_Equalizer_92
  include Equalizer::Methods
end
module Anonymous_Equalizer_92
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_91
end
class Mutant::Matcher::Scope < Mutant::Matcher
  def call(env); end
  def effective_matchers; end
  include Anonymous_Concord_94
  include Anonymous_Module_93
end
module Anonymous_Module_93
  def initialize(*args); end
  def scope; end
  include Anonymous_Equalizer_95
  include Equalizer::Methods
end
module Anonymous_Equalizer_95
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_94
end
class Mutant::Matcher::Filter < Mutant::Matcher
  def call(env); end
  include Anonymous_Concord_97
  include Anonymous_Module_96
end
module Anonymous_Module_96
  def initialize(*args); end
  def matcher; end
  def predicate; end
  include Anonymous_Equalizer_98
  include Equalizer::Methods
end
module Anonymous_Equalizer_98
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_97
end
class Mutant::Matcher::Null < Mutant::Matcher
  def call(_env); end
  include Anonymous_Concord_100
  include Anonymous_Module_99
end
module Anonymous_Module_99
  def initialize(*args); end
  include Anonymous_Equalizer_101
  include Equalizer::Methods
end
module Anonymous_Equalizer_101
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_100
end
class Mutant::Matcher::Static
  def call(_env); end
  include Anonymous_Concord_103
  include Anonymous_Module_102
end
module Anonymous_Module_102
  def initialize(*args); end
  def subjects; end
  include Anonymous_Equalizer_104
  include Equalizer::Methods
end
module Anonymous_Equalizer_104
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_103
end
class Mutant::Expression
  def match_length(other); end
  def matcher(*arg0); end
  def prefix?(other); end
  def self.new(*args, &block); end
  def self.try_parse(input); end
  def syntax(*arg0); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Memoizable
end
class Mutant::Expression::Parser
  def apply(input); end
  def expressions(input); end
  include Anonymous_Concord_106
  include Anonymous_Module_105
end
module Anonymous_Module_105
  def initialize(*args); end
  def types; end
  include Anonymous_Equalizer_107
  include Equalizer::Methods
end
module Anonymous_Equalizer_107
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_106
end
class Mutant::Expression::Method < Mutant::Expression
  def matcher; end
  def method_name; end
  def scope; end
  def scope_name; end
  def scope_symbol; end
  def self.anima; end
  def syntax(&block); end
  include Anima::InstanceMethods
  include Anonymous_Anima_109
  include Anonymous_Equalizer_108
  include Equalizer::Methods
end
module Anonymous_Anima_109
end
module Anonymous_Equalizer_108
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Expression::Methods < Mutant::Expression
  def match_length(expression); end
  def matcher; end
  def scope; end
  def scope_name; end
  def scope_symbol; end
  def self.anima; end
  def syntax(&block); end
  include Anima::InstanceMethods
  include Anonymous_Anima_111
  include Anonymous_Equalizer_110
  include Equalizer::Methods
end
module Anonymous_Anima_111
end
module Anonymous_Equalizer_110
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Expression::Namespace < Mutant::Expression
  def scope_name; end
  def self.anima; end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
  include Anima::InstanceMethods
  include Anonymous_Equalizer_112
  include Equalizer::Methods
end
module Anonymous_Equalizer_112
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Expression::Namespace::Recursive < Mutant::Expression::Namespace
  def initialize(*arg0); end
  def match_length(expression); end
  def matcher; end
  def syntax(&block); end
end
class Mutant::Expression::Namespace::Exact < Mutant::Expression::Namespace
  def matcher; end
  def syntax; end
end
class Mutant::Test
  def expression; end
  def id; end
  def identification; end
  def self.anima; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_113
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_113
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Mutant::Timer
  def self.elapsed; end
  def self.now; end
end
class Mutant::Transform
  def apply(*arg0); end
  def error(input:, cause: nil, message: nil); end
  def failure(value); end
  def lift_error(error); end
  def self.new(*args, &block); end
  def slug; end
  def success(value); end
  def wrap_error(error); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Memoizable
end
class Mutant::Transform::Error
  def cause; end
  def compact_message(&block); end
  def input; end
  def message; end
  def path; end
  def self.anima; end
  def trace(&block); end
  def transform; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_114
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_114
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Transform::Named < Mutant::Transform
  def apply(input); end
  def slug; end
  include Anonymous_Concord_116
  include Anonymous_Module_115
end
module Anonymous_Module_115
  def initialize(*args); end
  def name; end
  def transformer; end
  include Anonymous_Equalizer_117
  include Equalizer::Methods
end
module Anonymous_Equalizer_117
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_116
end
class Mutant::Transform::Index < Mutant::Transform
  def apply(input); end
  def index; end
  def self.anima; end
  def self.wrap(cause, index); end
  def slug(&block); end
  def transform; end
  include Anima::InstanceMethods
  include Anonymous_Anima_119
  include Anonymous_Equalizer_118
  include Equalizer::Methods
end
module Anonymous_Anima_119
end
module Anonymous_Equalizer_118
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Transform::Primitive < Mutant::Transform
  def apply(input); end
  def slug(&block); end
  include Anonymous_Concord_121
  include Anonymous_Module_120
end
module Anonymous_Module_120
  def initialize(*args); end
  def primitive; end
  include Anonymous_Equalizer_122
  include Equalizer::Methods
end
module Anonymous_Equalizer_122
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_121
end
class Mutant::Transform::Boolean < Mutant::Transform
  def apply(input); end
  include Anonymous_Concord_124
  include Anonymous_Module_123
end
module Anonymous_Module_123
  def initialize(*args); end
  include Anonymous_Equalizer_125
  include Equalizer::Methods
end
module Anonymous_Equalizer_125
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_124
end
class Mutant::Transform::Array < Mutant::Transform
  def apply(input); end
  def run(input); end
  include Anonymous_Concord_127
  include Anonymous_Module_126
end
module Anonymous_Module_126
  def initialize(*args); end
  def transform; end
  include Anonymous_Equalizer_128
  include Equalizer::Methods
end
module Anonymous_Equalizer_128
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_127
end
class Mutant::Transform::Hash < Mutant::Transform
  def allowed_keys(&block); end
  def apply(input); end
  def coerce_key(key, input); end
  def optional; end
  def reject_keys(input); end
  def required; end
  def required_keys(&block); end
  def self.anima; end
  def transform(input); end
  def transform_keys(keys, input); end
  def transform_optional(input); end
  def transform_required(input); end
  include Anima::InstanceMethods
  include Anonymous_Anima_130
  include Anonymous_Equalizer_129
  include Equalizer::Methods
end
module Anonymous_Anima_130
end
module Anonymous_Equalizer_129
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Transform::Hash::Symbolize < Mutant::Transform
  def apply(input); end
end
class Mutant::Transform::Hash::Key < Mutant::Transform
  def apply(input); end
  def slug(&block); end
  def transform; end
  def value; end
  include Anonymous_Concord_Public_132
  include Anonymous_Module_131
end
module Anonymous_Module_131
  def initialize(*args); end
  def transform; end
  def value; end
  include Anonymous_Equalizer_133
  include Equalizer::Methods
end
module Anonymous_Equalizer_133
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_132
end
class Mutant::Transform::Sequence < Mutant::Transform
  def apply(input); end
  include Anonymous_Concord_135
  include Anonymous_Module_134
end
module Anonymous_Module_134
  def initialize(*args); end
  def steps; end
  include Anonymous_Equalizer_136
  include Equalizer::Methods
end
module Anonymous_Equalizer_136
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_135
end
class Mutant::Transform::Exception < Mutant::Transform
  def apply(input); end
  include Anonymous_Concord_138
  include Anonymous_Module_137
end
module Anonymous_Module_137
  def block; end
  def error_class; end
  def initialize(*args); end
  include Anonymous_Equalizer_139
  include Equalizer::Methods
end
module Anonymous_Equalizer_139
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_138
end
class Mutant::Integration
  def all_tests(*arg0); end
  def call(*arg0); end
  def expression_parser; end
  def self.attempt_const_get(env); end
  def self.attempt_require(env); end
  def self.new(*args, &block); end
  def self.setup(env); end
  def setup; end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Anonymous_Module_140
  include Memoizable
end
module Anonymous_Module_140
  def config; end
  def initialize(*args); end
  include Anonymous_Equalizer_141
  include Equalizer::Methods
end
module Anonymous_Equalizer_141
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Integration::Null < Mutant::Integration
  def all_tests; end
  def call(tests); end
end
class Mutant::Selector
  def call(*arg0); end
  def self.new(*args, &block); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Memoizable
end
class Mutant::Selector::Expression < Mutant::Selector
  def call(subject); end
  include Anonymous_Concord_143
  include Anonymous_Module_142
end
module Anonymous_Module_142
  def initialize(*args); end
  def integration; end
  include Anonymous_Equalizer_144
  include Equalizer::Methods
end
module Anonymous_Equalizer_144
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_143
end
class Mutant::Selector::Null < Mutant::Selector
  def call(_subject); end
  include Anonymous_Equalizer_145
  include Equalizer::Methods
end
module Anonymous_Equalizer_145
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::World
  def capture_stdout(command); end
  def condition_variable; end
  def gem; end
  def inspect; end
  def io; end
  def json; end
  def kernel; end
  def load_path; end
  def marshal; end
  def mutex; end
  def object_space; end
  def open3; end
  def pathname; end
  def process; end
  def self.anima; end
  def stderr; end
  def stdout; end
  def thread; end
  def warnings; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_146
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_146
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Config
  def expression_parser; end
  def fail_fast; end
  def fail_fast?; end
  def includes; end
  def integration; end
  def isolation; end
  def jobs; end
  def matcher; end
  def reporter; end
  def requires; end
  def self.anima; end
  def self.load_config_file(world, config); end
  def self.load_contents(path); end
  def zombie; end
  def zombie?; end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anima::InstanceMethods
  include Anonymous_Equalizer_147
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_147
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::CLI
  def add(attribute, value); end
  def add_debug_options(opts); end
  def add_environment_options(opts); end
  def add_filter_options(opts); end
  def add_matcher(attribute, value); end
  def add_mutation_options(opts); end
  def parse(arguments); end
  def parse_match_expressions(expressions); end
  def self.apply(world, config, arguments); end
  def self.new(*arg0); end
  def self.run(world, default_config, arguments); end
  def with(attributes); end
  include Anonymous_Concord_149
  include Anonymous_Module_148
end
module Anonymous_Module_148
  def config; end
  def initialize(*args); end
  def world; end
  include Anonymous_Equalizer_150
  include Equalizer::Methods
end
module Anonymous_Equalizer_150
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_149
end
class Mutant::CLI::OptionParser < OptionParser
  def add_officious; end
end
class Mutant::Color
  def format(text); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_151
  include Memoizable
end
module Anonymous_Module_151
  def code; end
  def initialize(*args); end
  include Anonymous_Equalizer_152
  include Equalizer::Methods
end
module Anonymous_Equalizer_152
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Diff
  def colorized_diff(&block); end
  def diff(&block); end
  def diffs; end
  def hunks; end
  def max_length; end
  def minimized_hunk; end
  def self.build(old, new); end
  def self.colorize_line(line); end
  def self.lines(source); end
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Adamantium::Flat
  include Anonymous_Module_153
  include Memoizable
end
module Anonymous_Module_153
  def initialize(*args); end
  def new; end
  def old; end
  include Anonymous_Equalizer_154
  include Equalizer::Methods
end
module Anonymous_Equalizer_154
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Mutant::Runner
  def self.apply(env); end
  def self.mutation_test_config(env); end
  def self.reporter(env); end
  def self.run_driver(reporter, driver); end
  def self.run_mutation_analysis(env); end
end
class Mutant::Runner::Sink
  def initialize(*arg0); end
  def previous_mutation_results(subject); end
  def result(mutation_result); end
  def status; end
  def stop?; end
  include Anonymous_Concord_156
  include Anonymous_Module_155
end
module Anonymous_Module_155
  def env; end
  def initialize(*args); end
  include Anonymous_Equalizer_157
  include Equalizer::Methods
end
module Anonymous_Equalizer_157
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_156
end
module Mutant::Result
  def overhead; end
  def self.included(host); end
end
module Mutant::Result::Coverage
  def coverage; end
end
module Mutant::Result::ClassMethods
  def sum(name, collection); end
end
class Mutant::Result::Env
  def amount_mutation_results(&block); end
  def amount_mutations; end
  def amount_mutations_alive(&block); end
  def amount_mutations_killed(&block); end
  def env; end
  def failed_subject_results; end
  def killtime(&block); end
  def runtime; end
  def self.anima; end
  def stop?; end
  def subject_results; end
  def success?(&block); end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Mutant::Result::ClassMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_158
  include Equalizer::Methods
  include Memoizable
  include Mutant::Result::Coverage
end
module Anonymous_Equalizer_158
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Result::Test
  def output; end
  def passed; end
  def runtime; end
  def self.anima; end
  def tests; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Mutant::Result::ClassMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_159
  include Equalizer::Methods
  include Memoizable
  include Mutant::Result
end
module Anonymous_Equalizer_159
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Result::Test::VoidValue < Mutant::Result::Test
  def initialize; end
  def self.allocate; end
  def self.instance; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class Mutant::Result::Subject
  def alive_mutation_results(&block); end
  def amount_mutation_results; end
  def amount_mutations; end
  def amount_mutations_alive; end
  def amount_mutations_killed; end
  def killed_mutation_results(&block); end
  def killtime(&block); end
  def mutation_results; end
  def runtime(&block); end
  def self.anima; end
  def subject; end
  def success?; end
  def tests; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Mutant::Result::ClassMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_160
  include Equalizer::Methods
  include Memoizable
  include Mutant::Result::Coverage
end
module Anonymous_Equalizer_160
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Result::Mutation
  def isolation_result; end
  def killtime; end
  def mutation; end
  def runtime; end
  def self.anima; end
  def success?(&block); end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Mutant::Result::ClassMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_161
  include Equalizer::Methods
  include Memoizable
  include Mutant::Result
end
module Anonymous_Equalizer_161
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Reporter
  def delay(*arg0); end
  def progress(*arg0); end
  def report(*arg0); end
  def self.new(*args, &block); end
  def start(*arg0); end
  def warn(*arg0); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
end
class Mutant::Reporter::Null < Mutant::Reporter
  def progress(_object); end
  def report(_object); end
  def start(_object); end
  def warn(_object); end
  include Anonymous_Equalizer_162
  include Equalizer::Methods
end
module Anonymous_Equalizer_162
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Reporter::Sequence < Mutant::Reporter
  def delay; end
  def progress(value); end
  def report(value); end
  def start(value); end
  def warn(value); end
  include Anonymous_Concord_164
  include Anonymous_Module_163
end
module Anonymous_Module_163
  def initialize(*args); end
  def reporters; end
  include Anonymous_Equalizer_165
  include Equalizer::Methods
end
module Anonymous_Equalizer_165
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_164
end
class Mutant::Reporter::CLI < Mutant::Reporter
  def delay; end
  def progress(status); end
  def report(env); end
  def self.build(output); end
  def start(env); end
  def warn(message); end
  def write(frame); end
  include Anonymous_Concord_167
  include Anonymous_Module_166
end
module Anonymous_Module_166
  def format; end
  def initialize(*args); end
  def output; end
  include Anonymous_Equalizer_168
  include Equalizer::Methods
end
module Anonymous_Equalizer_168
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_167
end
class Mutant::Reporter::CLI::Printer
  def color?; end
  def colorize(color, message); end
  def info(string, *arguments); end
  def puts(string); end
  def run(*arg0); end
  def self.call(*args); end
  def self.define_delegator(name); end
  def self.delegate(*names); end
  def self.new(*args, &block); end
  def status(string, *arguments); end
  def status_color; end
  def success?; end
  def tty?; end
  def visit(printer, object); end
  def visit_collection(printer, collection); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  extend Procto::ClassMethods
  include AbstractType
  include Adamantium
  include Anonymous_Module_169
  include Memoizable
end
module Anonymous_Module_169
  def initialize(*args); end
  def object; end
  def output; end
  include Anonymous_Equalizer_170
  include Equalizer::Methods
end
module Anonymous_Equalizer_170
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Reporter::CLI::Printer::Config < Mutant::Reporter::CLI::Printer
  def run; end
end
class Mutant::Reporter::CLI::Printer::Env < Mutant::Reporter::CLI::Printer
  def amount_mutations; end
  def amount_selected_tests; end
  def amount_subjects; end
  def amount_total_tests; end
  def config; end
  def run; end
  def test_subject_ratio; end
end
class Mutant::Reporter::CLI::Printer::EnvProgress < Mutant::Reporter::CLI::Printer
  def amount_mutation_results; end
  def amount_mutations_alive; end
  def amount_mutations_killed; end
  def coverage; end
  def coverage_percent; end
  def env; end
  def killtime; end
  def mutations_per_second; end
  def overhead; end
  def overhead_percent; end
  def run; end
  def runtime; end
end
class Mutant::Reporter::CLI::Printer::EnvResult < Mutant::Reporter::CLI::Printer
  def failed_subject_results; end
  def run; end
end
class Mutant::Reporter::CLI::Printer::IsolationResult < Mutant::Reporter::CLI::Printer
  def print_log_messages; end
  def run; end
  def visit_chain; end
  def visit_child_error; end
  def visit_exception; end
  def visit_fork_error; end
  def visit_success; end
end
class Mutant::Reporter::CLI::Printer::MutationProgressResult < Mutant::Reporter::CLI::Printer
  def char(char); end
  def run; end
end
class Mutant::Reporter::CLI::Printer::MutationResult < Mutant::Reporter::CLI::Printer
  def evil_details; end
  def isolation_result; end
  def mutation; end
  def neutral_details; end
  def noop_details; end
  def original_node; end
  def print_details; end
  def print_no_diff_message; end
  def run; end
  def visit_isolation_result; end
end
class Mutant::Reporter::CLI::Printer::StatusProgressive < Mutant::Reporter::CLI::Printer
  def amount_mutation_results; end
  def amount_mutations; end
  def amount_mutations_alive; end
  def amount_mutations_killed; end
  def killtime; end
  def mutations_per_second; end
  def object; end
  def overhead; end
  def run; end
  def runtime; end
end
class Mutant::Reporter::CLI::Printer::SubjectProgress < Mutant::Reporter::CLI::Printer
  def amount_mutation_results; end
  def amount_mutations; end
  def amount_mutations_killed; end
  def coverage; end
  def killtime; end
  def overhead; end
  def print_mutation_results; end
  def print_progress_bar_finish; end
  def print_stats; end
  def run; end
  def runtime; end
  def subject; end
  def tests; end
end
class Mutant::Reporter::CLI::Printer::SubjectResult < Mutant::Reporter::CLI::Printer
  def alive_mutation_results; end
  def run; end
  def subject; end
  def tests; end
end
class Mutant::Reporter::CLI::Printer::TestResult < Mutant::Reporter::CLI::Printer
  def run; end
  def runtime; end
  def tests; end
end
class Mutant::Reporter::CLI::Format
  def delay; end
  def format(printer, object); end
  def progress(*arg0); end
  def self.new(*args, &block); end
  def start(*arg0); end
  extend AbstractType::AbstractMethodDeclarations
  include AbstractType
  include Anonymous_Module_171
end
module Anonymous_Module_171
  def initialize(*args); end
  def tty; end
  include Anonymous_Equalizer_172
  include Equalizer::Methods
end
module Anonymous_Equalizer_172
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Reporter::CLI::Format::Output
  def puts(*args, &block); end
  def tty?; end
  def write(*args, &block); end
  include Anonymous_Concord_174
  include Anonymous_Module_173
end
module Anonymous_Module_173
  def buffer; end
  def initialize(*args); end
  def tty; end
  include Anonymous_Equalizer_175
  include Equalizer::Methods
end
module Anonymous_Equalizer_175
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_174
end
class Mutant::Reporter::CLI::Format::Progressive < Mutant::Reporter::CLI::Format
  def new_buffer; end
  def progress(status); end
  def start(env); end
end
module Mutant::Repository
end
class Mutant::Repository::SubjectFilter
  def call(subject); end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Anonymous_Module_176
  include Memoizable
end
module Anonymous_Module_176
  def diff; end
  def initialize(*args); end
  include Anonymous_Equalizer_177
  include Equalizer::Methods
end
module Anonymous_Equalizer_177
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Repository::Diff
  def parse_line(work_dir, line); end
  def self.anima; end
  def to; end
  def touched_paths(&block); end
  def touches?(path, line_range); end
  def world; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_178
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_178
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Repository::Diff::Error < RuntimeError
end
class Mutant::Repository::Diff::Path
  def diff_ranges(&block); end
  def path; end
  def self.anima; end
  def to; end
  def touches?(line_range); end
  def world; end
  extend Adamantium::ClassMethods
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include Adamantium
  include Anima::InstanceMethods
  include Anonymous_Equalizer_179
  include Equalizer::Methods
  include Memoizable
end
module Anonymous_Equalizer_179
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Mutant::Repository::Diff::Ranges
  def self.mk_range(start, offset); end
  def self.parse(diff); end
  def self.parse_ranges(line); end
end
class Mutant::Variable
  def empty?; end
  def full?; end
  def initialize(condition_variable:, mutex:, value: nil); end
  def perform_put(value); end
  def read; end
  def synchronize(&block); end
  def take; end
  def take_timeout(timeout); end
  def try_put(value); end
  def wait(event); end
  def wait_full; end
  def wait_timeout(event, timeout); end
  def with; end
end
class Mutant::Variable::Result
  def self.new(*args, &block); end
  def timeout?; end
  def value(*arg0); end
  extend AbstractType::AbstractMethodDeclarations
  extend Adamantium::ClassMethods
  extend Adamantium::Flat
  extend Adamantium::ModuleMethods
  extend Memoizable::ModuleMethods
  include AbstractType
  include Adamantium
  include Memoizable
end
class Mutant::Variable::Result::Timeout < Mutant::Variable::Result
  def self.new; end
  include Anonymous_Equalizer_180
  include Equalizer::Methods
end
module Anonymous_Equalizer_180
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Variable::Result::Value < Mutant::Variable::Result
  def value; end
  include Anonymous_Concord_Public_182
  include Anonymous_Module_181
end
module Anonymous_Module_181
  def initialize(*args); end
  def value; end
  include Anonymous_Equalizer_183
  include Equalizer::Methods
end
module Anonymous_Equalizer_183
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_Public_182
end
class Mutant::Variable::IVar < Mutant::Variable
  def perform_take; end
  def put(value); end
end
class Mutant::Variable::IVar::Error < RuntimeError
end
class Mutant::Variable::MVar < Mutant::Variable
  def initialize(condition_variable:, mutex:, value: nil); end
  def modify; end
  def perform_take; end
  def put(value); end
end
class Mutant::Warnings
  def assert_no_recursion; end
  def call; end
  def capture(*arguments); end
  def initialize(warning); end
end
class Mutant::Warnings::RecursiveUseError < RuntimeError
end
class Mutant::Zombifier
  def call; end
  def find(logical_name); end
  def include?(logical_name); end
  def includes; end
  def initialize(*arg0); end
  def kernel; end
  def load_path; end
  def namespace; end
  def namespaced_node(source_path); end
  def original; end
  def pathname; end
  def require(logical_name); end
  def require_highjack; end
  def root_require; end
  def self.anima; end
  def self.call(*args); end
  def zombify(source_path); end
  include Anima::InstanceMethods
  include Anonymous_Anima_185
  include Anonymous_Equalizer_184
  include Equalizer::Methods
  include Mutant::AST::Sexp
end
module Anonymous_Anima_185
end
module Anonymous_Equalizer_184
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
class Mutant::Zombifier::LoadError < LoadError
end
module Mutant::Range
  def self.overlap?(left, right); end
end
module Mutant::License
  def self.apply(world); end
  def self.license_path(world); end
  def self.license_result(world); end
  def self.soft_fail(world, license_result); end
end
class Mutant::License::Subscription
  def failure(expected, actual); end
  def message(expected, actual); end
  def self.from_json(value); end
  def subscription_name; end
  def success; end
end
class Mutant::License::Subscription::Opensource < Mutant::License::Subscription
  def apply(world); end
  def check_subscription(actual); end
  def parse_remotes(input); end
  def self.from_json(value); end
  include Anonymous_Concord_187
  include Anonymous_Module_186
end
module Anonymous_Module_186
  def initialize(*args); end
  def repositories; end
  include Anonymous_Equalizer_188
  include Equalizer::Methods
end
module Anonymous_Equalizer_188
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_187
end
class Mutant::License::Subscription::Opensource::Repository
  def self.parse(input); end
  def self.parse_remote(input); end
  def self.parse_url(input); end
  def to_s; end
  include Anonymous_Concord_190
  include Anonymous_Module_189
end
module Anonymous_Module_189
  def host; end
  def initialize(*args); end
  def path; end
  include Anonymous_Equalizer_191
  include Equalizer::Methods
end
module Anonymous_Equalizer_191
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_190
end
class Mutant::License::Subscription::Commercial < Mutant::License::Subscription
  def apply(world); end
  def candidates(world); end
  def capture(world, command); end
  def commit_author(world); end
  def git_author(world); end
  def self.from_json(value); end
  include Anonymous_Concord_193
  include Anonymous_Module_192
end
module Anonymous_Module_192
  def authors; end
  def initialize(*args); end
  include Anonymous_Equalizer_194
  include Equalizer::Methods
end
module Anonymous_Equalizer_194
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_193
end
class Mutant::License::Subscription::Commercial::Author
  def to_s; end
  include Anonymous_Concord_196
  include Anonymous_Module_195
end
module Anonymous_Module_195
  def email; end
  def initialize(*args); end
  include Anonymous_Equalizer_197
  include Equalizer::Methods
end
module Anonymous_Equalizer_197
  def cmp?(comparator, other); end
  def hash; end
  def inspect; end
end
module Anonymous_Concord_196
end
module Warning
  def self.warn(*arguments); end
end
